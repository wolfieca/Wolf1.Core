using System;
using System.Collections.Generic;
using System.Text;
using Wolf1.Core.Document;
using Wolf1.Core.Legal;
using Wolf1.Core.Management;
using Wolf1.Core.MessageQueues;

namespace Wolf1.Core.Model
{
    class Debtor : IDebtor
    {
        private int _DebtorNumber;
        private IDemographics _Demographics;
        private IHistory _History;
        private IPaymentHistory _Payments;
        private Dictionary<String, ILegalAction> _LegalActions;
        private ICollector _Collector;
        private ISupplemental _SupplementalData;
        private DateTime _OriginalReceivedDate;
        private Dictionary<int, IDebt> _Debts;
        private Boolean _MailReturn;
        private Boolean _Locked;
        private Boolean _AccrueInterest;
        private Boolean _MergeAllowed;
        private Boolean _SplitAllowed;
        private IPerson _DebtorInfo;
        private Dictionary<String, IDocument> _DebtorDocuments;
        private IMessageQueue _MessageQueue;
        private IStrategy _Strategy;

        /// <summary>
        /// DebtorNumber is a system identifier for this debtor. This is distinct from
        /// the debtor's id number in the database, and the two may or may not coincide
        /// in practice. This is in contrast to the original Wizard system code, where
        /// the debtor number was the debtor's id number.
        /// System is the maintainer and generator of debtor numbers, and controls what
        /// happens when multiple threads try to create new debtor objects.
        /// </summary>
        public int DebtorNumber { get => _DebtorNumber; protected set { if (_DebtorNumber == 0) { _DebtorNumber = value; } } }

        /// <summary>
        /// CurrentBalance reflects the current balance owed by this debtor. It has no
        /// backing store and is generated on the fly by interrogating the individual
        /// debts belonging to this debtor.
        /// </summary>
        public decimal CurrentBalance { get => throw new NotImplementedException(); }

        /// <summary>
        /// OriginalBalance reflects the original balance owed by this debtor. It is
        /// generated on the fly by interrogating the individual debts belonging to
        /// this debtor.
        /// </summary>
        public decimal OriginalBalance { get => throw new NotImplementedException(); }

        /// <summary>
        /// The Demographics for this debtor. Because the demographics for a debtor are 
        /// protected information, users must have the correct access to be able to 
        /// see this data.
        /// </summary>
        public IDemographics Demographics { get => _Demographics; protected set { _Demographics = value; } }

        /// <summary>
        /// The History attached to this debtor. Like Demographics, the History is 
        /// sensitive to protected information. History items that contain protected
        /// information will be filtered unless the requester has access to that
        /// information.
        /// </summary>
        public IHistory History { get => _History; protected set { _History = value; } }

        /// <summary>
        /// The primary client for this debtor. This is generated by on the fly by
        /// interrogating the attached debts and finding the single client that is
        /// owed the greatest amount. Clients marked as being legal placeholder debtors
        /// are excluded from this by default, and will only be determined to be the 
        /// primary client if no regular-client debts are owed money. If the account
        /// is paid off, the primary client is the null client.
        /// </summary>
        public IClient PrimaryClient { get => throw new NotImplementedException();  }

        /// <summary>
        /// Payments that have been applied to this debtor. This is primarily used for
        /// reference purposes, as payments are added to the payment history for the
        /// debtor when they are applied to the debtor and the appropriate debts.
        /// </summary>
        public IPaymentHistory Payments { get => _Payments; protected set => _Payments = value; }

        /// <summary>
        /// Legal Actions that have been taken on this account. 
        /// </summary>
        public Dictionary<String,ILegalAction> LegalActions { get => _LegalActions; protected set => _LegalActions = value; }

        /// <summary>
        /// The collector currently assigned to this Debtor.
        /// </summary>
        public ICollector Collector { get => _Collector; protected set => _Collector = value; }

        /// <summary>
        /// Supplemental data attached to the debtor. Supplemental is a catch-all 
        /// category for data that pertains to the debtor, but is not strictly
        /// speaking demographic data. 
        /// </summary>
        public ISupplemental SupplementalData { get => _SupplementalData; protected set => _SupplementalData = value; }

        /// <summary>
        /// The date this debtor was originally received on the system. This date is set when the 
        /// debtor is first created (it transitions from newbiz to live)
        /// </summary>
        public DateTime OriginalReceivedDate { get => _OriginalReceivedDate; protected set => _OriginalReceivedDate = value; }

        /// <summary>
        /// The debts belonging to this debtor. Debts are added to or removed from 
        /// the debtor via Merge and Split operations.
        /// </summary>
        public Dictionary<int, IDebt> Debts { get => _Debts; protected set => _Debts = value; }
       
        /// <summary>
        /// Is the account locked? Locked accounts are read-only. This implies
        /// that the account cannot be merged or split, nor can it accrue interest.
        /// </summary>
        public bool Locked { get => _Locked; protected set => _Locked = value; }

        /// <summary>
        /// Can this account be merged with other accounts?
        /// </summary>
        public bool MergeAllowed { get => _MergeAllowed; protected set => _MergeAllowed = value; }

        /// <summary>
        /// Can individual debts be split from this debtor?
        /// </summary>
        public bool SplitAllowed { get => _SplitAllowed; protected set => _SplitAllowed = value; }

        /// <summary>
        /// The person this debtor belongs to.
        /// </summary>
        public IPerson DebtorInfo { get => _DebtorInfo; protected set => _DebtorInfo=value; }

        /// <summary>
        /// Is this debtor currently in a Mail Return status?
        /// </summary>
        public bool MailReturn { get => _MailReturn; protected set => _MailReturn = value; }

        /// <summary>
        /// Documents associated with this debtor. This includes Itemized Statements,
        /// and other support documents used to set up the debtor in the first place,
        /// and letters that have been sent on the debtor (including debt-specific
        /// letters), Credit Reports that have been pulled, phone recordings that
        /// are associated with this debtor, etc.
        /// </summary>
        public Dictionary<string, IDocument> DebtorDocuments => _DebtorDocuments;

        /// <summary>
        /// Every debtor has a MessageQueue attached to it. This allows for
        /// the debtor to be controlled either by the system or individual
        /// users. Scripts and various actions go through this queue.
        /// </summary>
        public IMessageQueue MessageQueue => _MessageQueue;

        /// <summary>
        /// Are this debtor's debts allowed to accrue interest?
        /// </summary>
        public bool AccrueInterest { get => _AccrueInterest; set => _AccrueInterest = value; }

        /// <summary>
        /// What is this debtor's current strategy? This is primarily for
        /// reference, since strategyies are largely self-running via the 
        /// message mechanism.
        /// </summary>
        public IStrategy Strategy { get => _Strategy; protected set => _Strategy = value; }

        /// <summary>
        /// Apply the specified payment. This registers the payment with the 
        /// Debtor, adding it to the Payment History for the Debtor. This is
        /// accomplished by iterating through the relevant Debts, and calling
        /// those Debts ApplyPayment methods. By implementation, a Payment is
        /// applicable to only a single Debt, which simplifies this. The 
        /// PaymentHistory for the Debtor is a conglomeration of the Debts'
        /// respective PaymentHistor(ies).
        /// </summary>
        /// <param name="Payment">The payment to apply.</param>
        /// <returns>True if the call succeeds.</returns>
        public bool ApplyPayment(IPayment Payment)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Assign this debtor to an Assignee (Attorney or Forwarder).
        /// </summary>
        /// <param name="AssignTo">The Assignee to send the debtor to.
        /// </param>
        /// <returns>The specified Assignee if successful, NULL 
        /// otherwise.</returns>
        public IAssignee Assign(IAssignee AssignTo)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Change the active strategy for this debtor.
        /// </summary>
        /// <param name="NewStrategy"></param>
        /// <returns></returns>
        public bool ChangeStrategy(IStrategy NewStrategy)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Merge a Debtor to this one.
        /// </summary>
        /// <param name="DebtorToMerge">The debtor to merge. Both Debtors
        /// in a merge must have MergeAllowed set to true. Demographic
        /// and Supplemental data are tested and merged with this debtor's
        /// data, as are legal data. 
        /// Legal Actions are considered atomic for purposes of merges and 
        /// splits, so any attempts to merge or split that would result
        /// in a legal action being broken up will fail.</param>
        /// <returns>The debtors as they will stand after the merge is
        /// commited. The Merge operation does not actually make the
        /// changes, to allow for the system to decide whether or when
        /// Merges will be committed (</returns>
        public IDebtor[] Merge(IDebtor DebtorToMerge)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Merge specific debts from the specified debtor to this debtor.
        /// This operators like the above Merge, with the exception that
        /// the specific debts to merge from the secondary account are 
        /// specified and are the only debts that will be affected.
        /// </summary>
        /// <param name="DebtorToMerge"></param>
        /// <param name="DebtsToMerge"></param>
        /// <returns></returns>
        public IDebtor[] Merge(IDebtor DebtorToMerge, List<IDebt> DebtsToMerge)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Merge specific listed debts to this debtor. Operates like the 
        /// above versions, except debts can come from different debtors.
        /// </summary>
        /// <param name="DebtsToMerge"></param>
        /// <returns></returns>
        public IDebtor[] Merge(List<IDebt> DebtsToMerge)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Reassign this debtor to a new Collector. This cleans up reminders 
        /// and such that are currently waiting on the debtor. The exact clean
        /// up process primarily consists of removing items currently waiting
        /// for the old collector, and then sending an initial message to the
        /// new collector's queue to be scheduled and handled as appropriate.
        /// </summary>
        /// <param name="NewCollector">The new Collector to assign this
        /// Debtor to</param>
        /// <returns></returns>
        public ICollector Reassign(ICollector NewCollector)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Reasign this debtor to a new Collector. The new Collector is not
        /// directtly specified, but will be of the specified Collector type/
        /// speciality. Otherwise, this works as the above version.
        /// </summary>
        /// <param name="CollectorType"></param>
        /// <returns></returns>
        public ICollector Reassign(string CollectorType)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Splits the listed debts from this Debtor, creating a new Debtor with 
        /// the same debtor information. Debt specific History items, payments,
        /// etc. are also moved along with the debts. Legal Actions can still not
        /// be broken up by a Split operation. The status on the new Debtor is 
        /// left the same as the status on this Debtor.
        /// </summary>
        /// <param name="DebtsToSplit"></param>
        /// <returns></returns>
        public IDebtor[] Split(List<IDebt> DebtsToSplit)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Splits the listed debts from this Debtor, creating a new Debtor with the 
        /// specified Status
        /// </summary>
        /// <param name="DebtsToSplit"></param>
        /// <param name="NewStatus"></param>
        /// <returns></returns>
        public IDebtor[] Split(List<IDebt> DebtsToSplit, IStatus NewStatus)
        {
            throw new NotImplementedException();
        }

        
    }
}
